"""===========================
pipeline_cite-seq-count.py
===========================

Overview
========

This pipeline takes raw fastq files that are from a multiplexed single cell experiment. The multiplexing has been performed using Hash tag oligo's (HTO). It runs Cite-seq-count on these ADT files.
 

Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general
information how to use cgat pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline.yml` file.

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_cite-seq-count.py config

Input files
-----------

* ADT fastq files that are in the format .fastq.1.gz and .fastq.2.gz.
* A tags.csv file must be present. This takes the form sample_name,hto_sequence,hto_name. The sample_name attribute in tags.csv must match the prefix to the fastq file i.e. if you are running CITE-seq-count on the fastq file sample1.fastq.1.gz and sample1.fastq.2.gz then you must have a tags.csv file that looks something like:

sample1,TGATGGCCTATTGGG,HTO1
sample1,TTCCGCCTCTCTTTG,HTO2
sample1,AGTAAGTTCAGCGTA,HTO3

In this example 3 samples have been multiplexed and ended up in sample1 fastq files. 

Outputs
--------

The counts for the HTOs for each sample (i.e.multiplexed) is output into cite-seq-count.dir/. These data can be used as input into HTODemux from Seurat in combination with cellranger count outputs for the corresponding GEX data.


Requirements
------------


Install CITE-seq-count:

   pip install CITE-seq-count


Pipeline output
===============


Glossary
========

.. glossary::


Code
====

"""
import sys
import os
import collections
import glob
from pathlib import Path
from ruffus import *
from cgatcore import pipeline as P

# load options from the config file
PARAMS = P.get_parameters(
    ["pipeline.yml"])

#get all files within the directory to process
SEQUENCEFILES = ("*.fastq.1.gz")

SEQUENCEFILES_REGEX = regex(
    r"(\S+).(fastq.1.gz)")

scriptsdir = os.path.dirname(os.path.abspath(__file__))
scriptsdir = P.snip(scriptsdir, "ocmsrnaseq") + "scripts"
PARAMS["scriptsdir"] = scriptsdir


########################################################
########################################################
########################################################
# create tag sets
########################################################
########################################################
########################################################

@follows(mkdir("tags.dir"))
@split(PARAMS["citeseqcount_tag_file"], "tags.dir/*_tags.csv")
def makeSampleTags(infile, outfiles):
    '''create sample tag files
    '''
    sample2tags = collections.defaultdict(set)
    for line in open(PARAMS["citeseqcount_tag_file"]).readlines():
        data = line[:-1].split(",")
        sample2tags[data[0]].add((data[1], data[2]))

    for sample, tag_list in sample2tags.items():
        outf = open("tags.dir/"+sample+"_tags.csv", "w")
        for seq, name in tag_list:
            outf.write(",".join([seq, name]) + "\n")
        outf.close()

########################################################
########################################################
########################################################
# Run CITE-seq-count
########################################################
########################################################
########################################################

@follows(mkdir("cite-seq-count.dir"), makeSampleTags)
@transform(SEQUENCEFILES,
           SEQUENCEFILES_REGEX,
           r"cite-seq-count.dir/\1/\1.log")
def runCiteSeqCount(infile, outfile):
    '''HTO count infile using CITE-seq-count
    '''

    tags = PARAMS["citeseqcount_tag_file"]

    # Note that at the moment I only deal with paired-end
    # reads
    p1 = infile
    p2 = p1.replace(".fastq.1.gz", ".fastq.2.gz")
    sample_name = P.snip(p1, ".fastq.1.gz")

    # get tag seqs
    tags = "tags.dir/"+sample_name+"_tags.csv"

    # make sample directory
    outdir = f"cite-seq-count.dir/{sample_name}"
    os.mkdir(outdir)

    cbf = PARAMS["citeseqcount_cbf"]
    cbl = PARAMS["citeseqcount_cbl"]
    umif = PARAMS["citeseqcount_umif"]
    umil = PARAMS["citeseqcount_umil"]
    ncells = PARAMS["citeseqcount_cells"]
    nthreads = PARAMS["citeseqcount_nthreads"]

    # add additional options
    options = PARAMS["citeseqcount_options"]

    statement = '''CITE-seq-Count
                   -R1 %(p1)s
                   -R2 %(p2)s
                   -t %(tags)s 
                   -cbf %(cbf)s
                   -cbl %(cbl)s
                   -umif %(umif)s
                   -umil %(umil)s
                   -cells %(ncells)s
                   -T %(nthreads)s
                   -o %(outdir)s 
                   %(options)s > %(outdir)s/%(sample_name)s.log
                '''
    P.run(statement)


########################################################
########################################################
########################################################

@follows(mkdir("run_report.dir"))
@transform(runCiteSeqCount,
           regex("cite-seq-count.dir/(\S+)/(\S+).log"),
           r"run_report.dir/\2_run_report.tsv")
def parseRunReport(infile, outfile):
    '''
       retrieves the percentage mapped from the run_report
       yaml file
    '''
    report_dir = os.path.dirname(infile)
    sample_name = P.snip(os.path.basename(infile), ".log") 
    report_file = os.path.join(report_dir, "run_report.yaml")
    statement = '''echo %(sample_name)s > %(outfile)s;
                   cat %(report_file)s
                   | sed -n 5p
                   | sed 's/Percentage mapped: //g'
                   >> %(outfile)s
                '''
    P.run(statement)

########################################################
########################################################
########################################################

@merge(parseRunReport, "run_report.dir/percentage_mapped.tsv")
def mergeRunReports(infiles, outfile):
    '''
    merge percentage mapped from run reports
    '''
    infiles = " ".join(infiles)
    statement = '''paste %(infiles)s > %(outfile)s;
                '''
    P.run(statement)


# ---------------------------------------------------
# Generic pipeline tasks
@follows(mergeRunReports)
def full():
    pass


def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)


if __name__ == "__main__":
    sys.exit(P.main(sys.argv))    
